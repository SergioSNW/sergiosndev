WebPack: Soporte CSS. Comentarios sobre modulos instalados (package.json)
    Parece que el plugin "optimize-css-assets-webpack-plugin" en WebPack 5.0++,
    ahora es "css-minimizer-webpack-plugin" 
    Instalado el nuevo y desinstalado el obsoleto con el cmd 
    > npm uninstall --save-dev optimize-css-assets-webpack-plugin
    He tenido que sustituir la constante siguiente en <webpack.config.js>
    const OptimizeCSSAssetsPlugin = require("css-minimizer-webpack-plugin");
    // const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");


webPack: Para la instalacion de SCSS y SASS
    He instalado/desinstalado. (solo queda el mini-css......)
        >> npm install   --save-dev mini-css-extract-plugin
        >> npm uninstall --save-dev css-minimizer-webpack-plugin
        >> npm uninstall --save-dev optimize-css-assets-webpack-plugin
        >> npm uninstall --save-dev node-sass

    Tambien desinstalo sass, pero al compilar lo pide, asi que reinstalo. Ahora pasa bien

    Curioso: Al correr >> npx webpack --watch 
    detecta cuando guardo fich: js/sass/css pero no veo que regenere el fich.Output 
    COMPROBAR que al navegar si reconoce los cambios introducidos
    
    Siempre que se compila de nuevo, general el fichero main.css en el raiz del tema. es
    posible que el watch actualice este fichero y el main-min.js lo referencie (¿¿¿???)
 

webPack: Para la instalacion de BABEL
    He ajustado todo a la version 7 de Babel (antes tenia un batiburrillo)
    El @babel/core ya estaba instalado. Luego, he instalado/desinstalado:
        npm install   --save-dev @babel/preset-env
        npm install   --save-dev @babel/cli
        npm uninstall --save-dev babel-core
        npm uninstall --save-dev babel-preset-env

    El @babel/cli es para probar la conversion: npx babel ./src/eventhorizon.js -o ./src/out.babel
    Si todo va a ser automatico, no sería necesario


Pruebas de componentes en local. Soporte para componentes LIT (escritos en js o en ts) 
    Instalaciones/desinstalaciones:
    a) Usadas
        npm install --save     lit
        npm install --save     clean-webpack-plugin  (Limpia el directorio dist antes de cada regeneracion)
        npm install --save-dev style-loader
        npm install --save-dev css-minimizer-webpack-plugin  (Reduce el tamaño de CSS)
        npm install --save-dev compression-webpack-plugin    (Comprime los packs - .gz)
        npm install --save-dev typescript ts-loader
    B) Sin uso actualmente, pero dejadas para ver posible utililidad futura
        npm install -D         webpack-dev-server   (Servidor-alternativa al GO-LIVE de vscode)
        npm install --save-dev copy-webpack-plugin  (Plugin para copiar ficheros)
        npm install --save-dev html-webpack-plugin  (Inyecta los packs en un html-template)
    Definido metodo de trabajo. Descrito en: ./src/@components/webpack.config.@libComponents.js


Pruebas para soporte de React 

    Instalaciones/desinstalaciones:
    a) Usadas
        npm install -D @babel/preset-react (transpilador de JSX)
        npm install -D react
        npm install -D react-dom

    He hecho varias pruebas para que el plugin html-webpack-plugin
    genere un html, tanto en base como con template, y no
    he conseguido que funciones. Por el momento, abandonado.

    El soporte para React (v18) ya funciona, incluso usando JSX.
    Probado con componentes funcionales (para mi, mas intuitivo) y con
    componentes de clase (un rollo en el uso de this, bind y paso de
    funciones hacia abajo).
    La principal diferencia con versiones anteriores radica en el metodo para
    renderizar la aplicacion:
    Antes:
        const container = document.getElementById('app');
        render(<App />, container);
    Ahora:
        const root = createRoot(document.querySelector("#app"))
        root.render(<App />)

    He alterado un poco la carpeta /src.
    Dejo sin operatividad el src/@components
    Ahora los componentes estan en src/js/components
    Y los ficheros maestros son:
        - src/js/indexL.js para montar los componentes Lit que se van a usar
        - src/js/indexR.js para montar la aplicacion React que se va a usar
    Estos ficheros generan un fichero bundle, por cada fichero maestro, en dist/ llamados
    indexL.bundle e indexR.bundle cuando compilamos con <npx webpack>

    Para arrancar un servidor de pruebas, se debe ejecutar <npx webpack serve>.
    Su document-root es public, que es el directorio que debe contener un index.html para 
    realizar las pruebas. Dicho html debe tener dos lineas con etiqueta src justo antes de
    cerrar el body.
            <script src="indexR.bundle"></script>
            <script src="indexL.bundle"></script>
        </body>
    Siempre apuntando estas librerias (aunque no lo estén) a public. Por lo que comprobado,
    el comando que arranca el servidor usa el webpack.config.js para compilar los fich.maestros
    pero el resultado no lo deja en dist sino que lo pone en memoria (como si estuviesen dentro de
    /public) y mantiene abierto un watch para que cualquier cambio en el html o en los bundles,   
    en cuanto se guarde actualice la memoria y refresque la pagina que tengamos abierta apuntando 
    al servidor (http://localhost:8081/)

    Incluido un nuevo script en package.json. Invocación: npm run comp
    El antiguo (libcomp) lo dejo hasta hablar con Sergio.




Bibliografia encontrada con posibilidades
    - pagina para hacer un plugin de WordPress
    https://productdesigner.es/curso/como-crear-una-web-app-con-wordpress-y-react-usando-frontity/anexo-2-creando-un-plugin-de-wordpress-para-nuestra-funcionalidad/


PENDIENTE:
pruebas debuger + mapas
opcion webpack: devServer
uso './pr_Juan_src/js/entryPoint.js' como punto de entrada (internamente llama a todo lo que quiero empaquetar)
generar doble paquete de js: ES5 y ES6, con tecnica para que cada navegador cargue lo que entienda